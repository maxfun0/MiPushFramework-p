name: Test CI

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build-debug:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        java-version: '11'
        distribution: 'temurin'
        cache: gradle
    
    - name: Fix signing configuration
      run: |
        echo "=== 修复签名配置 ==="
        
        # 1. 创建空的签名文件（如果 gradle 配置引用了 .yuuta.jks）
        echo "创建空的签名文件..."
        touch .yuuta.jks
        
        # 2. 创建调试签名配置
        echo "创建调试密钥库..."
        keytool -genkey -v -keystore debug.keystore \
          -storepass android -keypass android \
          -alias androiddebugkey -keyalg RSA \
          -keysize 2048 -validity 10000 \
          -dname "CN=Android Debug,O=Android,C=US" 2>/dev/null || echo "密钥库已创建"
    
    - name: Create local.properties
      run: |
        echo "创建 local.properties 文件..."
        # 使用 echo 命令逐行写入，避免 heredoc 问题
        echo "# 调试签名配置" > local.properties
        echo "key.alias=androiddebugkey" >> local.properties
        echo "key.password=android" >> local.properties
        echo "key.store=debug.keystore" >> local.properties
        echo "key.store.password=android" >> local.properties
        
        echo "local.properties 内容:"
        cat local.properties
    
    - name: Modify gradle files for CI
      run: |
        echo "=== 修改 gradle 文件以支持 CI ==="
        
        # 在项目的 gradle.properties 中添加 CI 标志
        echo "CI=true" >> gradle.properties
        echo "GITHUB_ACTIONS=true" >> gradle.properties
        
        # 修改 push/build.gradle 如果存在
        if [ -f "push/build.gradle" ]; then
          echo "在 push/build.gradle 中添加 CI 配置..."
          
          # 查找 android 块，在合适的位置添加
          if grep -q "android {" push/build.gradle; then
            # 备份文件
            cp push/build.gradle push/build.gradle.backup
            
            # 使用 sed 在 android 块后添加配置
            # 这个 sed 命令比较复杂，我们直接创建一个补丁
            cat > /tmp/patch.gradle << 'PATCH_EOF'

// === CI 环境配置 ===
signingConfigs {
    debug {
        if (System.getenv('CI') == 'true') {
            storeFile = null
            storePassword = null
            keyAlias = null
            keyPassword = null
        }
    }
}
PATCH_EOF
            
            # 在 android 块内添加配置
            awk '/android \{/{print; while(getline && !/^[[:space:]]*\}/) print; print ""; system("cat /tmp/patch.gradle"); print $0; next} 1' push/build.gradle > push/build.gradle.new
            mv push/build.gradle.new push/build.gradle
            
            echo "修改完成"
          fi
        fi
    
    - name: Build debug APKs
      run: |
        echo "=== 开始构建 Debug 版本 ==="
        
        # 设置版本名
        VERSION_NAME="dev-$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
        echo "版本名: $VERSION_NAME"
        
        # 方法1：尝试构建特定变体
        echo "方法1：构建 normalDebug..."
        ./gradlew :push:assembleNormalDebug -PversionName="$VERSION_NAME" --stacktrace || echo "normalDebug 构建失败，继续..."
        
        echo "方法1：构建 vc105Debug..."
        ./gradlew :push:assembleVc105Debug -PversionName="$VERSION_NAME" --stacktrace || echo "vc105Debug 构建失败，继续..."
        
        # 方法2：如果失败，尝试使用系统属性
        echo "方法2：使用系统属性构建..."
        ./gradlew :push:assembleDebug \
          -PversionName="$VERSION_NAME" \
          -DsigningConfig.storeFile="" \
          -DsigningConfig.storePassword="" \
          -DsigningConfig.keyAlias="" \
          -DsigningConfig.keyPassword="" \
          --stacktrace
    
    - name: Check build outputs
      run: |
        echo "=== 检查构建输出 ==="
        
        # 检查 APK 文件
        echo "查找所有 APK 文件..."
        find . -name "*.apk" -type f 2>/dev/null || echo "未找到 APK 文件"
        
        # 检查特定目录
        if [ -d "push/build/outputs/apk" ]; then
          echo "push/build/outputs/apk 内容:"
          ls -la push/build/outputs/apk/
          echo ""
          echo "normal/debug 目录:"
          ls -la push/build/outputs/apk/normal/debug/ 2>/dev/null || echo "目录不存在"
          echo ""
          echo "vc105/debug 目录:"
          ls -la push/build/outputs/apk/vc105/debug/ 2>/dev/null || echo "目录不存在"
        fi
    
    - name: Collect and upload APKs
      run: |
        echo "=== 收集和上传 APK ==="
        
        mkdir -p apk_output
        
        # 收集 normalDebug
        if [ -d "push/build/outputs/apk/normal/debug" ]; then
          echo "收集 normalDebug APK..."
          cp push/build/outputs/apk/normal/debug/*.apk apk_output/ 2>/dev/null || true
        fi
        
        # 收集 vc105Debug
        if [ -d "push/build/outputs/apk/vc105/debug" ]; then
          echo "收集 vc105Debug APK..."
          cp push/build/outputs/apk/vc105/debug/*.apk apk_output/ 2>/dev/null || true
        fi
        
        # 如果没有收集到，尝试其他位置
        if [ -z "$(ls -A apk_output 2>/dev/null)" ]; then
          echo "从其他位置收集 APK..."
          find . -name "*debug*.apk" -type f -exec cp {} apk_output/ \; 2>/dev/null || true
        fi
        
        echo "收集到的 APK:"
        ls -la apk_output/ || echo "无 APK 文件"
        
        # 统计数量
        APK_COUNT=$(ls apk_output/*.apk 2>/dev/null | wc -l || echo 0)
        echo "APK 数量: $APK_COUNT"
        
        if [ $APK_COUNT -eq 0 ]; then
          echo "错误：未生成 APK 文件"
          exit 1
        fi
    
    - name: Upload APK artifacts
      uses: actions/upload-artifact@v4
      with:
        name: debug-apks
        path: apk_output/
        if-no-files-found: error
